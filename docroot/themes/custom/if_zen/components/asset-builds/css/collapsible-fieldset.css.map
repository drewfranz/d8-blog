{"version":3,"sources":["forms/collapsible-fieldset/collapsible-fieldset.scss","forms/collapsible-fieldset/collapsible-fieldset.css","init/image-url/_image-url.scss","../node_modules/chroma-sass/sass/chroma/_internals.scss"],"names":[],"mappings":"AAeA;;EAEE,kBAAkB;ACdpB;;ADgBE;;EACE,cAAc;EACd,kBAAkB;EAClB,qEE0BuE;EFzBvE,4BAA4B;EAC5B,4BAA4B;ACZhC;;AAEA;EDaM,eAAe;EACf,mBAAmB;EACnB,sCAAsC;ACX5C;;ADeE;;EACE,cG+GmD;EH9GnD,eAAe;EACf,iBAAiB;ACXrB;;ADVA;;;EA0BI,sBAAsB;EACtB,oBAAoB;EACpB,qBAAqB;EACrB,WAAW;ACVf;;ADnBA;;;EAkCI,aAAa;ACTjB;;ADzBA;;;;EAuCI,sEENuE;EFOvE,4BAA4B;ACPhC;;AAEA;EDQM,0EEVqE;EFWrE,sCAAsC;ACN5C","file":"collapsible-fieldset.css","sourcesContent":["@import 'init';\n\n// Change the default sub-directory for the image-url() mixin.\n$image-url-subdirectory: 'forms/collapsible-fieldset';\n\n// Collapsible fieldset\n//\n// Fieldsets with optional entry fields can be hidden with collapsed fieldsets.\n//\n// .is-collapsed - The collapsed fieldset.\n//\n// Markup: collapsible-fieldset.twig\n//\n// Style guide: forms.collapsible-fieldset\n\n.collapsible-fieldset,\n%collapsible-fieldset {\n  position: relative;\n\n  &__legend {\n    display: block;\n    padding-left: 15px;\n    background-image: image-url('expanded.svg');\n    background-position: 4px 50%;\n    background-repeat: no-repeat;\n\n    @include rtl() {\n      padding-left: 0;\n      padding-right: 15px;\n      background-position: right 4px top 50%;\n    }\n  }\n\n  &__summary {\n    color: color(fieldset-summary);\n    font-size: .9em;\n    margin-left: .5em;\n  }\n\n  &.is-collapsed,\n  &--is-collapsed {\n    border-bottom-width: 0;\n    border-left-width: 0;\n    border-right-width: 0;\n    height: 1em;\n  }\n\n  &.is-collapsed &__wrapper,\n  &--is-collapsed__wrapper {\n    display: none;\n  }\n\n  &.is-collapsed &__legend,\n  &--is-collapsed__legend {\n    background-image: image-url('collapsed.svg');\n    background-position: 4px 50%;\n\n    @include rtl() {\n      background-image: image-url('collapsed-rtl.svg');\n      background-position: right 4px top 50%;\n    }\n  }\n}\n\n//\n// Drupal selectors.\n//\n\n.collapsible {\n  @extend %collapsible-fieldset;\n\n  .fieldset-legend {\n    @extend %collapsible-fieldset__legend;\n\n    .summary {\n      @extend %collapsible-fieldset__summary;\n    }\n  }\n\n  &.collapsed {\n    @extend %collapsible-fieldset--is-collapsed;\n\n    .fieldset-legend {\n      @extend %collapsible-fieldset--is-collapsed__legend;\n    }\n\n    .fieldset-wrapper {\n      @extend %collapsible-fieldset--is-collapsed__wrapper;\n    }\n  }\n}\n",".collapsible-fieldset,\n.collapsible {\n  position: relative;\n}\n\n.collapsible-fieldset__legend,\n.collapsible .fieldset-legend {\n  display: block;\n  padding-left: 15px;\n  background-image: url(../..//forms/collapsible-fieldset/expanded.svg);\n  background-position: 4px 50%;\n  background-repeat: no-repeat;\n}\n\n[dir=\"rtl\"] .collapsible-fieldset__legend, [dir=\"rtl\"] .collapsible .fieldset-legend, .collapsible [dir=\"rtl\"] .fieldset-legend {\n  padding-left: 0;\n  padding-right: 15px;\n  background-position: right 4px top 50%;\n}\n\n.collapsible-fieldset__summary,\n.collapsible .fieldset-legend .summary {\n  color: #aaaaaa;\n  font-size: .9em;\n  margin-left: .5em;\n}\n\n.collapsible-fieldset.is-collapsed, .collapsible-fieldset--is-collapsed,\n.is-collapsed.collapsible,\n.collapsible.collapsed {\n  border-bottom-width: 0;\n  border-left-width: 0;\n  border-right-width: 0;\n  height: 1em;\n}\n\n.collapsible-fieldset.is-collapsed .collapsible-fieldset__wrapper, .collapsible-fieldset--is-collapsed__wrapper,\n.is-collapsed.collapsible .collapsible-fieldset__wrapper,\n.collapsible.collapsed .fieldset-wrapper {\n  display: none;\n}\n\n.collapsible-fieldset.is-collapsed .collapsible-fieldset__legend, .collapsible-fieldset--is-collapsed__legend,\n.is-collapsed.collapsible .collapsible-fieldset__legend,\n.collapsible.collapsed .fieldset-legend, .collapsible-fieldset.is-collapsed .collapsible .fieldset-legend, .collapsible .collapsible-fieldset.is-collapsed .fieldset-legend,\n.is-collapsed.collapsible .fieldset-legend {\n  background-image: url(../..//forms/collapsible-fieldset/collapsed.svg);\n  background-position: 4px 50%;\n}\n\n[dir=\"rtl\"] .collapsible-fieldset.is-collapsed .collapsible-fieldset__legend, [dir=\"rtl\"] .collapsible-fieldset--is-collapsed__legend, [dir=\"rtl\"] .is-collapsed.collapsible .collapsible-fieldset__legend, [dir=\"rtl\"] .collapsible.collapsed .fieldset-legend, .collapsible.collapsed [dir=\"rtl\"] .fieldset-legend, [dir=\"rtl\"] .collapsible-fieldset.is-collapsed .collapsible .fieldset-legend, .collapsible [dir=\"rtl\"] .collapsible-fieldset.is-collapsed .fieldset-legend, [dir=\"rtl\"] .is-collapsed.collapsible .fieldset-legend {\n  background-image: url(../..//forms/collapsible-fieldset/collapsed-rtl.svg);\n  background-position: right 4px top 50%;\n}\n","// The relative path from the build directory, components/asset-builds/css/, to\n// the source directory, components/\n$image-url-path-to-source: '../../' !default;\n// The relative path from the root sass directory to where your components usually lie.\n$image-url-subdirectory: 'components' !default;\n\n// image-url()\n//\n// If you include your images next to your component Sass files, you need to\n// specify a url() to point from the generated CSS to the Sass source like this:\n//\n// ```css\n// content: url(../../components/is-quite/long.svg);\n// ```\n//\n// With the `image-url()` function the path to all your components is assumed to\n// start with `../../components/` and you just need to give it the last, short\n// bit of the path in your Sass code like this:\n//\n// ```scss\n// content: image-url(is-quite/short.svg);\n// ```\n//\n// If you want to point at an image that is not in the components sub-directory\n// of your sass directory, you can override the default $subdirectory by\n// passing it in as the first parameter of `image-url()` like this:\n//\n// ```scss\n// content: image-url(base, grouping/blockquote.svg);\n// ```\n//\n// which would output `url(../../base/grouping/blockquote.svg)`.\n//\n// $subdirectory   = $image-url-subdirectory - Optional. The relative path from\n//                   the root of your Sass source to the sub-directory where\n//                   components usually lie.\n// $path           - Required. The path to the image relative to the\n//                   `$subdirectory`.\n// $path-to-source = $image-url-path-to-source - Optional. The relative path\n//                   from the css build directory to the sass source directory.\n//\n// Style guide: sass.mixins.image-url\n@function image-url($subdirectory, $path: null, $path-to-source: $image-url-path-to-source) {\n  // If only 1 parameter is given, its value is intended for the $path.\n  @if type-of($path) == 'null' {\n    $path: $subdirectory;\n    $subdirectory: $image-url-subdirectory;\n  }\n  @return url(unquote($path-to-source + '/' + $subdirectory + '/' + $path));\n}\n","// Internals\n//\n// Helper functions that query the internal data structure in $chroma. These are\n// not part of the public API and are subject to change at any time.\n//\n// Weight: 10\n//\n// Style guide: internals\n\n// Import the global variables needed by all of Chroma.\n@import './variables';\n\n// chroma-has-scheme($scheme)\n//\n// Checks if the named color scheme exists.\n//\n// Style guide: internals.chroma-has-scheme\n@function chroma-has-scheme($scheme) {\n  @return map-has-key(map-get($chroma, 'schemes'), $scheme);\n}\n\n// chroma-schemes()\n//\n// Returns a list of all color schemes in $chroma.\n//\n// Style guide: internals.chroma-schemes\n@function chroma-schemes() {\n  @return map-keys(map-get($chroma, 'schemes'));\n}\n\n// chroma-has-color($name [, $scheme])\n//\n// Checks if the named color exists in the given scheme or its parent schemes.\n// Returns false or a string of the scheme name that contains the color.\n//\n// Style guide: internals.chroma-has-color\n@function chroma-has-color($name, $scheme: $chroma-active-scheme) {\n  $current-scheme: $scheme;\n  @while $current-scheme {\n    @if map-has-key(map-get($chroma, 'names'), \"#{$current-scheme}::#{$name}\") {\n      @return $current-scheme;\n    }\n    // Look in the parent scheme.\n    $current-scheme: map-get(map-get(map-get($chroma, 'schemes'), $current-scheme), 'parent');\n  }\n  @return false;\n}\n\n// _chroma-add-name()\n//\n// Private function that adds a color to the data structure of the $chroma\n// variable.\n//\n// Style guide: internals._chroma-add-name\n@function _chroma-add-name($scheme, $name, $value: false, $reference: false, $referenced_by: (), $function: false, $parameters: ()) {\n  $names: map-merge(\n    map-get($chroma, 'names'),\n    (\"#{$scheme}::#{$name}\": (\n      value         : $value,\n      reference     : $reference,\n      referenced_by : $referenced_by,\n      function      : $function,\n      parameters    : $parameters,\n    ))\n  );\n\n  @return map-merge(\n    $chroma,\n    ('names': $names)\n  );\n}\n\n// _chroma-init()\n//\n// Private function that sets up the initial data structure of the $chroma\n// variable. Can be called repeatedly without damaging existing data.\n//\n// Style guide: internals._chroma-init\n@function _chroma-init() {\n  @if length($chroma) == 0 {\n    @return (\n      'schemes': (\n        $CHROMA_DEFAULT_SCHEME : (\n          'description': '',\n          'parent': false,\n        ),\n      ),\n      'skins': (),\n      'names': (),\n    );\n  }\n  @else {\n    @return $chroma;\n  }\n}\n\n// is-old-libsass()\n//\n// libsass before 3.3.0 is funky, making it very hard for Chroma to do its job.\n//\n// - `inspect([color])` returns the original value instead of returning the\n//   string equivalent, so you can't cast a color to a string.\n// - `type-of('[color keyword]')` thinks that these strings are colors.\n// - `map-has-key()` works properly, thankfully. So:\n//   - `map-has-key((white: ''), white)` correctly returns `true`\n//   - `map-has-key(('white': ''), 'white')` correctly returns `true`\n//   - `map-has-key((white: ''), 'white')` correctly returns `false`\n//   - `map-has-key(('white': ''), white)` correctly returns `false`\n//   This means we can cobble together a replacement for `type-of()`. And a\n//   partial replacement for `inspect()` that works for everything except\n//   dangerous color keywords.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n//\n// Style guide: internals._is-old-libsass\n@function _is-old-libsass() {\n  @return if(type-of('white') == 'color', true, false);\n}\n\n// _is-keyword-string($name)\n//\n// Normally, `type-of()` can be used to tell if a given value is a string. But\n// LibSass versions before 3.3.0 think that color keywords in strings are still\n// colors and not strings. This function works, regardless of LibSass bugs.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n//\n// Style guide: internals._is-keyword-string\n@function _is-keyword-string($name) {\n  @return if(map-has-key($_chroma-css4-color-keywords-in-strings, $name), true, false);\n}\n\n// _safe-call()\n//\n// LibSass incorrectly throws an error when using the variable argument\n// indicator, ..., with an overloaded function; e.g. rgba(). To work-around this\n// bug, we call rgba() with direct parameters.\n//\n// @TODO: Remove when the fix for https://github.com/sass/libsass/issues/2205 is released.\n//\n// Style guide: internals._safe-call\n@function _safe-call($function, $parameters...) {\n  @if $function == rgba {\n    @return rgba(nth($parameters, 1), nth($parameters, 2));\n  }\n  @return call(get-function($function), $parameters...);\n}\n"]}